Variation 6: SPFA (Shortest Path Faster Algorithm)The Problem:Standard Bellman-Ford is $O(VE)$, which is too slow for $V=10^5$. Dijkstra fails on negative edges. You need something faster for sparse graphs with negative edges.The Solution:SPFA is an optimized Bellman-Ford. Instead of scanning all edges every iteration, we only scan edges starting from nodes that were relaxed in the previous step. It uses a Queue, similar to BFS.Warning: The worst-case complexity is still $O(VE)$, and it is easy to create test cases that kill SPFA. However, on random graphs, it runs in roughly $O(2E)$.Code Snippet:

bool spfa(int s) {
    vector<long long> dist(n + 1, INF);
    vector<int> cnt(n + 1, 0);      // Tracks how many times a node is updated
    vector<bool> in_queue(n + 1, false); // Is node currently in queue?
    queue<int> q;

    dist[s] = 0;
    q.push(s);
    in_queue[s] = true;

    while (!q.empty()) {
        int u = q.front(); q.pop();
        in_queue[u] = false;

        for (auto& e : adj[u]) { // adj is vector<pair<int, int>>
            int v = e.first;
            int w = e.second;
            
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                
                // SPFA Logic: Only push if not already waiting in queue
                if (!in_queue[v]) {
                    q.push(v);
                    in_queue[v] = true;
                    
                    // Cycle Check: If a node is updated N times, cycle exists
                    cnt[v]++;
                    if (cnt[v] > n) return true; // Negative Cycle Detected
                }
            }
        }
    }
    return false;
}

