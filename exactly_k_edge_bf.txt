Variation 5: Shortest Path with "Exactly K" EdgesThe Problem:Find the shortest path from $S$ to $E$ using exactly $K$ edges. The graph may have negative edges (but usually no negative cycles for the problem to be well-defined).The Solution (Dynamic Programming / Bellman-Ford Logic):Bellman-Ford is naturally a DP algorithm where the $i$-th iteration finds the shortest path using at most $i$ edges. We can modify it to be strict.State: dp[k][u] = Shortest distance to node u using exactly k edges.Transition: dp[k][v] = min(dp[k][v], dp[k-1][u] + w)
// We need two arrays: prev_dist (k-1 edges) and curr_dist (k edges)
vector<long long> dist(n + 1, INF);
dist[start_node] = 0;

for (int k = 1; k <= K; k++) {
    vector<long long> next_dist(n + 1, INF); // Reset to INF for "exactly k" logic
    for (auto& e : edges) {
        if (dist[e.u] != INF) {
            next_dist[e.v] = min(next_dist[e.v], dist[e.u] + e.w);
        }
    }
    dist = next_dist;
}
// dist[target] is now the answer

Note: If $K$ is very large (e.g., $10^9$), you solve this using Matrix Exponentiation with the $(\min, +)$ operator instead of $(\times, +)$.
